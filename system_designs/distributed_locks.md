Locks - used to lock critical sections to save from threats of same process
Mutex - lock critical sections to save from threats of multiple processes, at any given time one client can acquire lock
Semaphore - used across processes

### Distributed Locks

When different processes operates on same resource in mutually exclusive way.

#### How

Create an instance(may be Redis instance) where we can save key(which could be Instance1 which acquired one file) and client can release that lock by deleting the key

Problem: Single Point of failure, what if master goes down

Solution: Add slave OR Add replicas

What? Replicas are asyncronous, it will defeat Mutex. 
For example1: Instance1 did entry in redis1, and Instance2 might be reading from redis2(which is not yet updated) and will do same entry as Instance1 did
For example2: Instance1 did entry in redis1, and redis1 dies and redis2 promoted to master

### Implementation with a single instance

acquire lock

```
SET resource_name random_value NX PX 3000
```
NX - Set if not exist
PX - expiry time in miliseconds

This is how any client can acquire a lock and when same client is done its task can remove the lock by following commad:

```
random_value = redis.get('resource_name')
if random_value == client_will_have_this_string
	redis.delete('resource_name')
else
   return 0	
end
```

This **random_value** is unique for each client, so that deletion can be done by client who acquired it. This Basically randome value is used to release the lock in safe way.

Here random_value can be generated by combination of client_id+unix_timestamp may be.

### Lets extend it to distributed system using Redlock algorithm

Steps to acquire the lock in N redis instances, lets N = 5

1. current_timestamp = Take current timestamp
2. client will try to acquire lock in all 5 machines sequentially using same key and random_value. If client is able to acquire majority of locks which is 3, then it is considered as acquired. There is time-out on client which is less than PX time. Its there so that we can prevent client to blocked for so long if one machine goes down and client can move to next machine asap.
3. client also compute total elapsed time, which is substracting time from current_timestamp and if its less than PX time then client can acquire the lock
4. if lock is acquired then its validity time = intial px time - current_timestamp
5. if client failed to acquire, it will try to unlock all instances even if they were locked by this client.

Processes are using local clock of machines which might have small difference in time with each other. Worst case scenerio: client is able to acquire lock majority of machines. Client set first key at T1(time we sample before contacting first server) and last key set at T2.
we are sure about first key will expire at = TTL - T2 - T1 - clock drift, 
all other keys might expire later and we sure about last key

Will other client able to acquire the lock as first key will be expired first?
No, because it checks wheather N/2+1 keys exists


``
clock drift refers to where clock does not run at exactly same rate as reference to clock
``

Continue Reading

```
https://redis.io/topics/distlock
https://github.com/antirez/redlock-rb
```








